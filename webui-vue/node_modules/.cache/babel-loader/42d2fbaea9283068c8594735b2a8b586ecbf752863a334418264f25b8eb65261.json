{"ast":null,"code":"import { createRouter, createWebHashHistory } from 'vue-router';\n\n//Do not change store or routes import.\n//Exact match alias set to support\n//dotenv customizations.\nimport store from '../store';\nimport routes from './routes';\nconst router = createRouter({\n  history: createWebHashHistory(),\n  routes,\n  linkExactActiveClass: 'nav-link--current',\n  scrollBehavior() {\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n});\nfunction allowRouterToNavigate(to, next, currentUserRole) {\n  if (to.matched.some(record => record.meta.requiresAuth)) {\n    if (store.getters['authentication/isLoggedIn']) {\n      if (to.meta.exclusiveToRoles) {\n        // The privilege for the specific router was verified using the\n        // exclusiveToRoles roles in the router.\n        if (to.meta.exclusiveToRoles.includes(currentUserRole)) {\n          next();\n        } else {\n          next('*');\n        }\n        return;\n      }\n      next();\n      return;\n    }\n    next('/login');\n  } else {\n    next();\n  }\n}\nrouter.beforeEach((to, from, next) => {\n  let currentUserRole = store.getters['global/userPrivilege'];\n  // condition will get satisfied if user refreshed after login\n  if (!currentUserRole && store.getters['authentication/isLoggedIn']) {\n    // invoke API call to get the role ID\n    store.dispatch('authentication/getSessionPrivilege').then(() => {\n      let currentUserRole = store.getters['global/userPrivilege'];\n      allowRouterToNavigate(to, next, currentUserRole);\n    })\n    // our store got out of sync, start afresh\n    .catch(() => {\n      console.log('Failed to obtain current Roles, logging out.');\n      store.dispatch('authentication/logout');\n    });\n  } else {\n    allowRouterToNavigate(to, next, currentUserRole);\n  }\n});\nexport default router;","map":{"version":3,"names":["createRouter","createWebHashHistory","store","routes","router","history","linkExactActiveClass","scrollBehavior","x","y","allowRouterToNavigate","to","next","currentUserRole","matched","some","record","meta","requiresAuth","getters","exclusiveToRoles","includes","beforeEach","from","dispatch","then","catch","console","log"],"sources":["/home/zenchenko/openbmc/build/evb-ast2500/workspace/sources/webui-vue/src/router/index.js"],"sourcesContent":["import { createRouter, createWebHashHistory } from 'vue-router';\n\n//Do not change store or routes import.\n//Exact match alias set to support\n//dotenv customizations.\nimport store from '../store';\nimport routes from './routes';\n\nconst router = createRouter({\n  history: createWebHashHistory(),\n  routes,\n  linkExactActiveClass: 'nav-link--current',\n  scrollBehavior() {\n    return { x: 0, y: 0 };\n  },\n});\n\nfunction allowRouterToNavigate(to, next, currentUserRole) {\n  if (to.matched.some((record) => record.meta.requiresAuth)) {\n    if (store.getters['authentication/isLoggedIn']) {\n      if (to.meta.exclusiveToRoles) {\n        // The privilege for the specific router was verified using the\n        // exclusiveToRoles roles in the router.\n        if (to.meta.exclusiveToRoles.includes(currentUserRole)) {\n          next();\n        } else {\n          next('*');\n        }\n        return;\n      }\n      next();\n      return;\n    }\n    next('/login');\n  } else {\n    next();\n  }\n}\n\nrouter.beforeEach((to, from, next) => {\n  let currentUserRole = store.getters['global/userPrivilege'];\n  // condition will get satisfied if user refreshed after login\n  if (!currentUserRole && store.getters['authentication/isLoggedIn']) {\n    // invoke API call to get the role ID\n    store\n      .dispatch('authentication/getSessionPrivilege')\n      .then(() => {\n        let currentUserRole = store.getters['global/userPrivilege'];\n        allowRouterToNavigate(to, next, currentUserRole);\n      })\n      // our store got out of sync, start afresh\n      .catch(() => {\n        console.log('Failed to obtain current Roles, logging out.');\n        store.dispatch('authentication/logout');\n      });\n  } else {\n    allowRouterToNavigate(to, next, currentUserRole);\n  }\n});\n\nexport default router;\n"],"mappings":"AAAA,SAASA,YAAY,EAAEC,oBAAoB,QAAQ,YAAY;;AAE/D;AACA;AACA;AACA,OAAOC,KAAK,MAAM,UAAU;AAC5B,OAAOC,MAAM,MAAM,UAAU;AAE7B,MAAMC,MAAM,GAAGJ,YAAY,CAAC;EAC1BK,OAAO,EAAEJ,oBAAoB,CAAC,CAAC;EAC/BE,MAAM;EACNG,oBAAoB,EAAE,mBAAmB;EACzCC,cAAcA,CAAA,EAAG;IACf,OAAO;MAAEC,CAAC,EAAE,CAAC;MAAEC,CAAC,EAAE;IAAE,CAAC;EACvB;AACF,CAAC,CAAC;AAEF,SAASC,qBAAqBA,CAACC,EAAE,EAAEC,IAAI,EAAEC,eAAe,EAAE;EACxD,IAAIF,EAAE,CAACG,OAAO,CAACC,IAAI,CAAEC,MAAM,IAAKA,MAAM,CAACC,IAAI,CAACC,YAAY,CAAC,EAAE;IACzD,IAAIhB,KAAK,CAACiB,OAAO,CAAC,2BAA2B,CAAC,EAAE;MAC9C,IAAIR,EAAE,CAACM,IAAI,CAACG,gBAAgB,EAAE;QAC5B;QACA;QACA,IAAIT,EAAE,CAACM,IAAI,CAACG,gBAAgB,CAACC,QAAQ,CAACR,eAAe,CAAC,EAAE;UACtDD,IAAI,CAAC,CAAC;QACR,CAAC,MAAM;UACLA,IAAI,CAAC,GAAG,CAAC;QACX;QACA;MACF;MACAA,IAAI,CAAC,CAAC;MACN;IACF;IACAA,IAAI,CAAC,QAAQ,CAAC;EAChB,CAAC,MAAM;IACLA,IAAI,CAAC,CAAC;EACR;AACF;AAEAR,MAAM,CAACkB,UAAU,CAAC,CAACX,EAAE,EAAEY,IAAI,EAAEX,IAAI,KAAK;EACpC,IAAIC,eAAe,GAAGX,KAAK,CAACiB,OAAO,CAAC,sBAAsB,CAAC;EAC3D;EACA,IAAI,CAACN,eAAe,IAAIX,KAAK,CAACiB,OAAO,CAAC,2BAA2B,CAAC,EAAE;IAClE;IACAjB,KAAK,CACFsB,QAAQ,CAAC,oCAAoC,CAAC,CAC9CC,IAAI,CAAC,MAAM;MACV,IAAIZ,eAAe,GAAGX,KAAK,CAACiB,OAAO,CAAC,sBAAsB,CAAC;MAC3DT,qBAAqB,CAACC,EAAE,EAAEC,IAAI,EAAEC,eAAe,CAAC;IAClD,CAAC;IACD;IAAA,CACCa,KAAK,CAAC,MAAM;MACXC,OAAO,CAACC,GAAG,CAAC,8CAA8C,CAAC;MAC3D1B,KAAK,CAACsB,QAAQ,CAAC,uBAAuB,CAAC;IACzC,CAAC,CAAC;EACN,CAAC,MAAM;IACLd,qBAAqB,CAACC,EAAE,EAAEC,IAAI,EAAEC,eAAe,CAAC;EAClD;AACF,CAAC,CAAC;AAEF,eAAeT,MAAM","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}