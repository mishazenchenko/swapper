{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport api, { isPasswordExpired } from '@/store/api';\nimport Cookies from 'js-cookie';\nimport router from '@/router';\nimport { roles } from '@/router/routes';\nconst AuthenticationStore = {\n  namespaced: true,\n  state: {\n    consoleWindow: null,\n    authError: false,\n    xsrfCookie: Cookies.get('XSRF-TOKEN'),\n    isAuthenticatedCookie: Cookies.get('IsAuthenticated'),\n    sessionURI: localStorage.getItem('sessionURI'),\n    xAuthToken: null\n  },\n  getters: {\n    consoleWindow: state => state.consoleWindow,\n    authError: state => state.authError,\n    isLoggedIn: state => {\n      // We might have gotten XSRF-TOKEN (and HttpOnly SESSION cookie) by Mutual TLS authentication,\n      // without going through explicit Session creation\n      return state.xsrfCookie !== undefined || state.isAuthenticatedCookie == 'true' || state.xAuthToken !== null;\n    },\n    // Used to authenticate WebSocket connections via subprotocol value\n    token: state => state.xsrfCookie\n  },\n  mutations: {\n    authSuccess(state, {\n      session,\n      token\n    }) {\n      state.authError = false;\n      state.xsrfCookie = Cookies.get('XSRF-TOKEN');\n      // Preserve session data across page reloads and browser restarts\n      localStorage.setItem('sessionURI', session);\n      state.sessionURI = session;\n      // If we didn't get the XSRF cookie it means we are talking to a\n      // Redfish implementation that is not bmcweb. In this case get the token\n      // from headers and send it with the future requests, do not permanently\n      // save anywhere.\n      if (state.xsrfCookie === undefined) {\n        api.set_auth_token(token);\n        state.xAuthToken = token;\n      }\n    },\n    authError(state, authError = true) {\n      state.authError = authError;\n    },\n    logout(state) {\n      Cookies.remove('XSRF-TOKEN');\n      Cookies.remove('IsAuthenticated');\n      api.set_auth_token(undefined);\n      localStorage.removeItem('storedUsername');\n      state.xsrfCookie = undefined;\n      state.isAuthenticatedCookie = undefined;\n      localStorage.removeItem('sessionURI');\n      state.sessionURI = null;\n      state.xAuthToken = null;\n      state.consoleWindow = false;\n    }\n  },\n  actions: {\n    login({\n      commit\n    }, {\n      username,\n      password\n    }) {\n      commit('authError', false);\n      return api.post('/redfish/v1/SessionService/Sessions', {\n        UserName: username,\n        Password: password\n      }).then(({\n        headers,\n        data\n      }) => {\n        commit('authSuccess', {\n          session: headers['location'],\n          token: headers['x-auth-token']\n        });\n        setSessionPrivilege(commit, data);\n        return isPasswordExpired(data);\n      }).catch(error => {\n        commit('authError');\n        throw new Error(error);\n      });\n    },\n    logout({\n      commit,\n      state\n    }) {\n      api.delete(state.sessionURI).catch(() => console.log(\"Couldn't DELETE Session, proceeding with the logout anyway to get in sync with the backend.\")).then(() => commit('logout')).then(() => router.push('/login')).catch(error => console.log(error));\n    },\n    getSessionPrivilege({\n      commit,\n      state\n    }) {\n      return api.get(state.sessionURI).then(({\n        data\n      }) => setSessionPrivilege(commit, data));\n    },\n    resetStoreState({\n      state\n    }) {\n      state.authError = false;\n      state.xsrfCookie = Cookies.get('XSRF-TOKEN');\n      state.isAuthenticatedCookie = Cookies.get('IsAuthenticated');\n    }\n  }\n};\nconst setSessionPrivilege = (commit, data) => {\n  // If the backend didn't provide the role information in the Session object\n  // our best bet is to assume the Administrator role to avoid hiding\n  // potentially useful UI elements. Everything security-sensitive is validated\n  // on the backend side anyway, so this is safe.\n  commit('global/setPrivilege', data.Roles?.[0] ?? roles.administrator, {\n    root: true\n  });\n};\nexport default AuthenticationStore;","map":{"version":3,"names":["api","isPasswordExpired","Cookies","router","roles","AuthenticationStore","namespaced","state","consoleWindow","authError","xsrfCookie","get","isAuthenticatedCookie","sessionURI","localStorage","getItem","xAuthToken","getters","isLoggedIn","undefined","token","mutations","authSuccess","session","setItem","set_auth_token","logout","remove","removeItem","actions","login","commit","username","password","post","UserName","Password","then","headers","data","setSessionPrivilege","catch","error","Error","delete","console","log","push","getSessionPrivilege","resetStoreState","Roles","administrator","root"],"sources":["/home/zenchenko/openbmc/build/evb-ast2500/workspace/sources/webui-vue/src/store/modules/Authentication/AuthenticanStore.js"],"sourcesContent":["import api, { isPasswordExpired } from '@/store/api';\nimport Cookies from 'js-cookie';\nimport router from '@/router';\nimport { roles } from '@/router/routes';\n\nconst AuthenticationStore = {\n  namespaced: true,\n  state: {\n    consoleWindow: null,\n    authError: false,\n    xsrfCookie: Cookies.get('XSRF-TOKEN'),\n    isAuthenticatedCookie: Cookies.get('IsAuthenticated'),\n    sessionURI: localStorage.getItem('sessionURI'),\n    xAuthToken: null,\n  },\n  getters: {\n    consoleWindow: (state) => state.consoleWindow,\n    authError: (state) => state.authError,\n    isLoggedIn: (state) => {\n      // We might have gotten XSRF-TOKEN (and HttpOnly SESSION cookie) by Mutual TLS authentication,\n      // without going through explicit Session creation\n      return (\n        state.xsrfCookie !== undefined ||\n        state.isAuthenticatedCookie == 'true' ||\n        state.xAuthToken !== null\n      );\n    },\n    // Used to authenticate WebSocket connections via subprotocol value\n    token: (state) => state.xsrfCookie,\n  },\n  mutations: {\n    authSuccess(state, { session, token }) {\n      state.authError = false;\n      state.xsrfCookie = Cookies.get('XSRF-TOKEN');\n      // Preserve session data across page reloads and browser restarts\n      localStorage.setItem('sessionURI', session);\n      state.sessionURI = session;\n      // If we didn't get the XSRF cookie it means we are talking to a\n      // Redfish implementation that is not bmcweb. In this case get the token\n      // from headers and send it with the future requests, do not permanently\n      // save anywhere.\n      if (state.xsrfCookie === undefined) {\n        api.set_auth_token(token);\n        state.xAuthToken = token;\n      }\n    },\n    authError(state, authError = true) {\n      state.authError = authError;\n    },\n    logout(state) {\n      Cookies.remove('XSRF-TOKEN');\n      Cookies.remove('IsAuthenticated');\n      api.set_auth_token(undefined);\n      localStorage.removeItem('storedUsername');\n      state.xsrfCookie = undefined;\n      state.isAuthenticatedCookie = undefined;\n      localStorage.removeItem('sessionURI');\n      state.sessionURI = null;\n      state.xAuthToken = null;\n      state.consoleWindow = false;\n    },\n  },\n  actions: {\n    login({ commit }, { username, password }) {\n      commit('authError', false);\n      return api\n        .post('/redfish/v1/SessionService/Sessions', {\n          UserName: username,\n          Password: password,\n        })\n        .then(({ headers, data }) => {\n          commit('authSuccess', {\n            session: headers['location'],\n            token: headers['x-auth-token'],\n          });\n          setSessionPrivilege(commit, data);\n          return isPasswordExpired(data);\n        })\n        .catch((error) => {\n          commit('authError');\n          throw new Error(error);\n        });\n    },\n    logout({ commit, state }) {\n      api\n        .delete(state.sessionURI)\n        .catch(() =>\n          console.log(\n            \"Couldn't DELETE Session, proceeding with the logout anyway to get in sync with the backend.\",\n          ),\n        )\n        .then(() => commit('logout'))\n        .then(() => router.push('/login'))\n        .catch((error) => console.log(error));\n    },\n    getSessionPrivilege({ commit, state }) {\n      return api\n        .get(state.sessionURI)\n        .then(({ data }) => setSessionPrivilege(commit, data));\n    },\n    resetStoreState({ state }) {\n      state.authError = false;\n      state.xsrfCookie = Cookies.get('XSRF-TOKEN');\n      state.isAuthenticatedCookie = Cookies.get('IsAuthenticated');\n    },\n  },\n};\n\nconst setSessionPrivilege = (commit, data) => {\n  // If the backend didn't provide the role information in the Session object\n  // our best bet is to assume the Administrator role to avoid hiding\n  // potentially useful UI elements. Everything security-sensitive is validated\n  // on the backend side anyway, so this is safe.\n  commit('global/setPrivilege', data.Roles?.[0] ?? roles.administrator, {\n    root: true,\n  });\n};\n\nexport default AuthenticationStore;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}